**Process vs. Pool**
+ Pool和之前的Process的不同点是丢向Pool的函数有返回值，而Process的没有返回值。

**apply_async vs. apply**
+ `pool.apply_async`采用异步方式调用task，`pool.apply` 则是同步方式调用,同步方式意味着下一个task需要等待上一个task完成后才能开始运行。
+ apply_async()中只能传递一个值，它只会放入一个核进行运算，但是传入值时要注意是可迭代的，所以在传入值后需要加逗号, 同时需要用get()方法获取返回值
+ map() 放入迭代参数，返回多个结果
+ apply_async()只能放入一组参数，并返回一个结果，如果想得到map()的效果需要通过迭代
  
```
def task(pid):
    # do something
    return result

results = []
for i in xrange(0, 4):
    result = pool.apply_async(task, args=(i,))
    results.append(result)
pool.close() #回收进程池
pool.join()  #回收进程池

for result in results:
    print(result.get())

```
> 在这里不免有人要疑问，为什么不直接在 for 循环中直接 result.get()呢？这是因为pool.apply_async之后的语句都是阻塞执行的，调用 result.get() 会等待上一个任务执行完之后才会分配下一个任务。事实上，获取返回值的过程最好放在进程池回收之后进行，避免阻塞后面的语句。

----
```
#CPU核心数
cpus = multiprocessing.cpu_count()
```

https://morvanzhou.github.io/tutorials/python-basic/multiprocessing/3-queue/

